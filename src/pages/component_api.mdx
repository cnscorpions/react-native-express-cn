import WebPlayer from '../components/WebPlayer'
import example from '../examples/component_api'

## **`this.props`**

通过向`constructor`传递属性，这些属性被称之为`props`，我们可以在组件实例化的时候配置`Components`。为了改变组件的渲染和行为，我们通过`this.props`来访问`props`。然而，**React不允许我们在组件的方法中修改`props`**。

一个父级元素可以在任何时间修改它的子元素的`props`。这个子元素会自己re-render以反应新的配置参数。

尽管父级组件传入的`props`已经发生改变，一个子组件可能不执行re-render，加入`shouldComponentUpdate() { return false; }`即可（关于这个函数在组件生命周期的章节有更多内容）。

## **`this.state`**

`Components`通过`state`对象来维护内部状态。我们可以在组件的方法中访问`this.state`。不像`props`，父级组件无法访问子组件的`state`，因为`state`旨在管理子组件的内部状态而非外部配置。

注意你不应该直接给`state`对象某个key赋值，例如`this.state.foo = 'bar'`，反而应该使用`this.setState()`方法。

## **`this.setState(object newState)`**

通过传一个对象给`this.setState()`方法，`Components`可以更新它们的状态。对象的key将会合并到`this.state`对象中，覆盖掉现存的keys。

# Example

下面的例子包含一个`Counter`组件，它通过`state.count`内部维护着运行时间。`App`组件渲染带有两个`props`：`size`和`color`的`Counter`组件。`App`能够容易地渲染几个不同尺寸和颜色地`Counter`组件。

<WebPlayer {...example} />
